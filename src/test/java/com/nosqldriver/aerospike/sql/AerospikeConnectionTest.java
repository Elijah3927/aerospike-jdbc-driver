package com.nosqldriver.aerospike.sql;

import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Properties;

import static com.nosqldriver.aerospike.sql.TestDataUtils.testConn;
import static java.sql.Connection.TRANSACTION_NONE;
import static java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
import static java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT;
import static java.sql.ResultSet.CONCUR_READ_ONLY;
import static java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
import static java.sql.ResultSet.TYPE_FORWARD_ONLY;
import static java.sql.Statement.RETURN_GENERATED_KEYS;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

class AerospikeConnectionTest {
    @Test
    void createValidConnectionWithoutNamespace() throws SQLException {
        Connection conn = new AerospikeConnection("jdbc:aerospike:localhost", new Properties());
        assertTrue(conn.isValid(1));
        conn.setReadOnly(true);
        assertTrue(conn.isReadOnly());
        conn.setReadOnly(false);
        assertFalse(conn.isReadOnly());

        assertNull(conn.getCatalog());
        conn.setCatalog(null);
        conn.setCatalog("something"); // ignored
        assertNull(conn.getCatalog());

        conn.close();
        assertFalse(conn.isValid(1));
        assertThrows(SQLException.class, () -> conn.setReadOnly(true));
        assertThrows(SQLException.class, () -> conn.setReadOnly(false));

    }

    @Test
    void createValidConnectionWithPort() throws SQLException {
        Connection conn = new AerospikeConnection("jdbc:aerospike:localhost:3000", new Properties());
        conn.close();
    }


    @Test
    void createValidConnectionWithNamespace() throws SQLException {
        Connection conn = new AerospikeConnection("jdbc:aerospike:localhost/test", new Properties());
        conn.close();
    }

    @Test
    void createInValidConnectionWrongHost() throws SQLException {
        assertThrows(SQLException.class, () -> new AerospikeConnection("jdbc:aerospike:someotherhostthatdoesnotexist", new Properties()));
    }

    @Test
    void createInValidConnectionWrongPort() throws SQLException {
        assertThrows(SQLException.class, () -> new AerospikeConnection("jdbc:aerospike:localhost:4321", new Properties()));
    }


    @Test
    void createStatement() throws SQLException {
        assertNotNull(testConn.createStatement());
        assertNotNull(testConn.createStatement(TYPE_FORWARD_ONLY, CONCUR_READ_ONLY));
        assertNotNull(testConn.createStatement(TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, testConn.getHoldability()));

        assertThrows(SQLException.class, () -> testConn.createStatement(TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, 123));
        assertThrows(SQLException.class, () -> testConn.createStatement(TYPE_FORWARD_ONLY, 123, testConn.getHoldability()));
        assertThrows(SQLException.class, () -> testConn.createStatement(123, CONCUR_READ_ONLY, testConn.getHoldability()));
    }

    @Test
    void prepareStatement() throws SQLException {
        String query = "select 1";
        assertNotNull(testConn.prepareStatement(query));
        assertNotNull(testConn.prepareStatement(query, TYPE_FORWARD_ONLY, CONCUR_READ_ONLY));
        assertNotNull(testConn.prepareStatement(query, TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, testConn.getHoldability()));

        assertThrows(SQLException.class, () -> testConn.prepareStatement(query, TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, 123));
        assertThrows(SQLException.class, () -> testConn.prepareStatement(query, TYPE_FORWARD_ONLY, 123, testConn.getHoldability()));
        assertThrows(SQLException.class, () -> testConn.prepareStatement(query, 123, CONCUR_READ_ONLY, testConn.getHoldability()));

        // autogenerated keys requirement is ignored if queyry is not insert
        assertNotNull(testConn.prepareStatement(query, RETURN_GENERATED_KEYS));
        assertNotNull(testConn.prepareStatement(query, new int[] {1}));
        assertNotNull(testConn.prepareStatement(query, new String[] {"id"}));
    }


    @Test
    void holdability() throws SQLException {
        // default value
        assertEquals(HOLD_CURSORS_OVER_COMMIT, testConn.getHoldability());
        // set same value as default
        testConn.setHoldability(HOLD_CURSORS_OVER_COMMIT);
        assertEquals(HOLD_CURSORS_OVER_COMMIT, testConn.getHoldability());

        // set other valid value
        testConn.setHoldability(CLOSE_CURSORS_AT_COMMIT);
        assertEquals(CLOSE_CURSORS_AT_COMMIT, testConn.getHoldability());
        // try to set invalid value and check that exception was thrown and previous value was not changed
        assertThrows(SQLException.class, () -> testConn.setHoldability(12345));
        assertEquals(CLOSE_CURSORS_AT_COMMIT, testConn.getHoldability());

        // restore default
        testConn.setHoldability(HOLD_CURSORS_OVER_COMMIT);
        assertEquals(HOLD_CURSORS_OVER_COMMIT, testConn.getHoldability());

        // try to set invalid value and check that exception was thrown and previous value was not changed
        assertThrows(SQLException.class, () -> testConn.setHoldability(12345));
        assertEquals(HOLD_CURSORS_OVER_COMMIT, testConn.getHoldability());
    }


    @Test
    void unsupported() throws SQLException {
        String query = "select 1";
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.setSavepoint());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.setSavepoint("something"));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.rollback());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.rollback(null));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.releaseSavepoint(null));

        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareCall(query));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareCall(query, TYPE_FORWARD_ONLY, CONCUR_READ_ONLY));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareCall(query, TYPE_FORWARD_ONLY, CONCUR_READ_ONLY, testConn.getHoldability()));

        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareStatement("insert into mytest (id) values (?)", RETURN_GENERATED_KEYS));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareStatement("insert into mytest (id) values (?)", new int[] {1}));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.prepareStatement("insert into mytest (id) values (?)", new String[] {"id"}));

        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createBlob());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createClob());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createNClob());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createSQLXML());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createArrayOf("string", new Object[0]));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.createStruct("person", new Object[0]));

        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.setNetworkTimeout(command -> {}, 123));
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.nativeSQL(query));


        assertEquals(TRANSACTION_NONE, testConn.getTransactionIsolation());
        testConn.setTransactionIsolation(TRANSACTION_NONE);
        assertEquals(TRANSACTION_NONE, testConn.getTransactionIsolation());
        assertThrows(SQLFeatureNotSupportedException.class, () -> testConn.setTransactionIsolation(TRANSACTION_READ_UNCOMMITTED));
        assertEquals(TRANSACTION_NONE, testConn.getTransactionIsolation());
   }
}